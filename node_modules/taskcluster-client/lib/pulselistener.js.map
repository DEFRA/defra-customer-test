{
  "version": 3,
  "sources": [
    "pulselistener.js"
  ],
  "names": [
    "events",
    "require",
    "util",
    "amqplib",
    "Promise",
    "debug",
    "_",
    "assert",
    "slugid",
    "URL",
    "buildPulseConnectionString",
    "options",
    "username",
    "password",
    "hostname",
    "join",
    "retryConnect",
    "connectionString",
    "retries",
    "connect",
    "noDelay",
    "timeout",
    "catch",
    "err",
    "PulseConnection",
    "defaults",
    "namespace",
    "fake",
    "parsed",
    "parse",
    "auth",
    "split",
    "_connectionString",
    "_conn",
    "_connecting",
    "inherits",
    "EventEmitter",
    "prototype",
    "that",
    "resolve",
    "retval",
    "accept",
    "reject",
    "once",
    "conn",
    "then",
    "on",
    "stack",
    "emit",
    "Error",
    "close",
    "undefined",
    "exports",
    "PulseListener",
    "connection",
    "credentials",
    "_bindings",
    "_options",
    "prefetch",
    "queueName",
    "maxLength",
    "_fake",
    "_connection",
    "bind",
    "binding",
    "exchange",
    "routingKeyPattern",
    "push",
    "_channel",
    "_queueName",
    "bindQueue",
    "channel",
    "channelCreated",
    "createConfirmChannel",
    "channel_",
    "exclusive",
    "v4",
    "queueCreated",
    "opts",
    "durable",
    "autoDelete",
    "assertQueue",
    "bindingsCreated",
    "all",
    "map",
    "pause",
    "_fakeListening",
    "cancel",
    "_consumerTag",
    "resume",
    "consume",
    "msg",
    "_handle",
    "result",
    "consumerTag",
    "fakeMessage",
    "message",
    "content",
    "Buffer",
    "payload",
    "fields",
    "routingKey",
    "redelivered",
    "properties",
    "headers",
    "CC",
    "routes",
    "r",
    "JSON",
    "toString",
    "Array",
    "filter",
    "route",
    "test",
    "exec",
    "routingKeyReference",
    "forEach",
    "routing",
    "keys",
    "i",
    "length",
    "ref",
    "multipleWords",
    "name",
    "shift",
    "j",
    "pop",
    "listeners",
    "handler",
    "call",
    "ack",
    "nack",
    "deleteQueue"
  ],
  "mappings": "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",
  "file": "pulselistener.js",
  "sourceRoot": "../src",
  "sourcesContent": [
    "var events    = require('events');\nvar util      = require('util');\nvar amqplib   = require('amqplib');\nvar Promise   = require('promise');\nvar debug     = require('debug')('taskcluster-client:PulseListener');\nvar _         = require('lodash');\nvar assert    = require('assert');\nvar slugid    = require('slugid');\nvar URL       = require('url');\n\n/**\n * Build Pulse ConnectionString, from options on the form:\n * {\n *   username:          // Pulse username (optional, if connectionString)\n *   password:          // Pulse password (optional, if connectionString)\n *   hostname:          // Hostname to use (defaults to pulse.mozilla.org)\n * }\n */\nvar buildPulseConnectionString = function(options) {\n  assert(options.username, 'options.username password is required');\n  assert(options.password, 'options.password is required');\n\n  // Construct connection string\n  return [\n    'amqps://',         // Ensure that we're using SSL\n    options.username,\n    ':',\n    options.password,\n    '@',\n    options.hostname || 'pulse.mozilla.org',\n    ':',\n    5671,                // Port for SSL\n  ].join('');\n};\n\n/** Connect to AMQP server while retrying connection establishment */\nvar retryConnect = function(connectionString, retries) {\n  return amqplib.connect(connectionString, {\n    noDelay: true,\n    timeout: 30 * 1000,\n  }).catch(function(err) {\n    if (retries > 0) {\n      return retryConnect(connectionString, retries - 1);\n    }\n    throw err;\n  });\n};\n\n/**\n * Create PulseConnection from `options` on the form:\n * {\n *   namespace:         // Namespace to prefix queues/exchanges (optional)\n *                      // defaults to `username` if given otherwise \"\"\n *   username:          // Username to connect with (and namespace if not given)\n *   password:          // Password to connect with\n *   hostname:          // Hostname to connect to using username/password\n *                      // defaults to pulse.mozilla.org\n *   connectionString:  // connectionString cannot be used with username,\n *                      // password and/or hostname.\n *   fake:              // If true, do not connect to pulse (for tests)\n * }\n */\nvar PulseConnection = function(options) {\n  assert(typeof options === 'object', 'options is required');\n  options = _.defaults({}, options, {\n    namespace:          options.username || '',\n  });\n\n  // a fake connection does notihng but signal its fake-ness to listeners\n  if (options.fake) {\n    this.fake = true;\n    return;\n  }\n\n  if (!options.connectionString) {\n    options.connectionString = buildPulseConnectionString(options);\n  } else {\n    assert(!options.username, 'Can\\'t take `username` along with `connectionString`');\n    assert(!options.password, 'Can\\'t take `password` along with `connectionString`');\n    assert(!options.hostname, 'Can\\'t take `hostname` along with `connectionString`');\n  }\n\n  // If namespace was not explicitly set infer it from connection string...\n  if (!options.namespace) {\n    var parsed = URL.parse(options.connectionString);\n    options.namespace = parsed.auth.split(':')[0];\n  }\n\n  this.namespace = options.namespace;\n  this._connectionString = options.connectionString;\n\n  // Private properties\n  this._conn              = null;\n  this._connecting        = false;\n};\n\n// Inherit from events.EventEmitter\nutil.inherits(PulseConnection, events.EventEmitter);\n\n/** Returns a promise for a connection */\nPulseConnection.prototype.connect = function() {\n  var that = this;\n\n  // Connection if we have one\n  if (this._conn) {\n    return Promise.resolve(this._conn);\n  }\n\n  // If currently connecting, give a promise for this result\n  var retval = new Promise(function(accept, reject) {\n    that.once('connection', function(err, conn) {\n      if (err) {\n        return reject(err);\n      }\n      return accept(conn);\n    });\n  });\n\n  // Connect if we're not already doing this\n  if (!this._connecting) {\n    this._connecting = true;\n    retryConnect(this._connectionString, 7).then(function(conn) {\n      // Save reference to the connection\n      that._conn = conn;\n\n      // Setup error handling\n      conn.on('error', function(err) {\n        debug('Connection error in Connection: %s', err, err.stack);\n        that.emit('error', err);\n      });\n      conn.on('close', function() {\n        if (!that._conn) {\n          return; // Forget this, if close() was called\n        }\n        debug('Connection closed unexpectedly');\n        that.emit('error', new Error(\n          'Connection closed unexpectedly, likely server initiated shutdown'\n        ));\n      });\n\n      // We're no longer connecting, emit event notifying anybody waiting\n      that._connecting = false;\n      that.emit('connection', null, conn);\n    }).then(null, function(err) {\n      // Notify of connection error\n      that.emit('connection', err);\n    });\n  }\n\n  // Return promise waiting for event\n  return retval;\n\n};\n\n/** Close the connection */\nPulseConnection.prototype.close = function() {\n  var conn = this._conn;\n  if (conn) {\n    this._conn = null;\n    return conn.close();\n  }\n  return Promise.resolve(undefined);\n};\n\n// Export PulseConnection\nexports.PulseConnection = PulseConnection;\n\n/**\n * Create new PulseListener\n *\n * options: {\n *   prefetch:            // Max number of messages unacknowledged to hold\n *   queueName:           // Queue name, defaults to exclusive auto-delete queue\n *   connection:          // PulseConnection object (or credentials)\n *   credentials: {\n *     namespace:         // Namespace to prefix queues/exchanges (optional)\n *                        // defaults to `username` if given otherwise \"\"\n *     username:          // Pulse username\n *     password:          // Pulse password\n *     hostname:          // Hostname to connect to using username/password\n *                        // defaults to pulse.mozilla.org\n *     connectionString:  // connectionString overwrites username/password and\n *                        // hostname (if given)\n *     fake:              // if true, do not connect to pulse (for tests)\n *   }\n *   maxLength:           // Maximum queue size, undefined for none\n * }\n *\n * You must provide `connection` either as an instance of `PulseConnection` or\n * as options given to `PulseConnection`. If options for `PulseConnection` is\n * given, then the connection will be closed along with the listener.\n */\nvar PulseListener = function(options) {\n  var that = this;\n  assert(options,             'options are required');\n  assert(options.connection ||\n         options.credentials, 'options.connection or credentials is required');\n  this._bindings = [];\n  this._options = _.defaults(options, {\n    prefetch:               5,\n    queueName:              undefined,\n    maxLength:              undefined,\n  });\n\n  this._fake = options.credentials && options.credentials.fake ||\n               options.connection && options.connection.fake;\n\n  // Ensure that we have connection object\n  this._connection = options.connection || null;\n  if (!(this._connection instanceof PulseConnection) && !this._fake) {\n    this._connection = new PulseConnection(options.credentials);\n    // If listener owner the connection, then connection errors are also\n    // listener errors\n    this._connection.on('error', function(err) {\n      that.emit('error', err);\n    });\n  }\n};\n\n// Inherit from events.EventEmitter\nutil.inherits(PulseListener, events.EventEmitter);\n\n/**\n * Bind listener to exchange with routing key and optional routing key\n * reference used to parse routing keys.\n *\n * binding: {\n *   exchange:              '...',  // Exchange to bind\n *   routingKeyPattern:     '...',  // Routing key as string\n *   routingKeyReference:   {...}   // Reference used to parse routing keys\n * }\n *\n * if `routingKeyReference` is provided for the exchange from which messages\n * arrive the listener will parse the routing key and make it available as a\n * dictionary on the message.\n *\n * **Note,** the arguments for this method is easily constructed using an\n * instance of `Client`, see `createClient`.\n */\nPulseListener.prototype.bind = function(binding) {\n  assert(typeof binding.exchange === 'string',\n    'Can\\'t bind to unspecified exchange!');\n  assert(typeof binding.routingKeyPattern === 'string',\n    'routingKeyPattern is required!');\n  this._bindings.push(binding);\n  if (!this._fake && this._channel) {\n    debug('Binding %s to %s with pattern \\'%s\\'',\n      this._queueName || 'exclusive queue',\n      binding.exchange, binding.routingKeyPattern);\n    return this._channel.bindQueue(\n      this._queueName,\n      binding.exchange,\n      binding.routingKeyPattern\n    );\n  } else {\n    return Promise.resolve(null);\n  }\n};\n\n/** Connect, setup queue and binding to exchanges */\nPulseListener.prototype.connect = function() {\n  var that = this;\n\n  assert(!this._fake, 'Fake listeners can\\'t connect');\n\n  // Return channel if we have one\n  if (this._channel) {\n    return Promise.resolve(this._channel);\n  }\n\n  // Create AMQP connection and channel\n  var channel = null;\n  var channelCreated = this._connection.connect().then(function(conn) {\n    that._conn = conn;\n    return that._conn.createConfirmChannel();\n  }).then(function(channel_) {\n    channel = channel_;\n    channel.on('error', function(err) {\n      // Prevent invalidation of the connection, by someone calling .close()\n      // this way channel.close() won't be called when .close() is called.\n      that._channel = null;\n      debug('Channel error in PulseListener: ', err.stack);\n      that.emit('error', err);\n    });\n    channel.on('close', function() {\n      if (!that._channel) {\n        return; // Ignore if close() was called\n      }\n      debug('Channel was closed unexpectedly');\n      that.emit('error', new Error(\n        'Channel closed unexpectedly, likely server initiated shutdown'\n      ));\n    });\n    return channel.prefetch(that._options.prefetch);\n  });\n\n  // Find queue name and decide if this is an exclusive queue\n  var exclusive = !this._options.queueName;\n  // Construct queue name\n  this._queueName = [\n    'queue',                      // Required by pulse security model\n    this._connection.namespace,   // Required by pulse security model\n    this._options.queueName || 'exclusive/' + slugid.v4(),\n  ].join('/');\n\n  // Create queue\n  var queueCreated = channelCreated.then(function() {\n    var opts = {\n      exclusive:  exclusive,\n      durable:    !exclusive,\n      autoDelete: exclusive,\n    };\n    // Set max length if provided\n    if (that._options.maxLength) {\n      opts.maxLength =  that._options.maxLength;\n    }\n    return channel.assertQueue(that._queueName, opts);\n  });\n\n  // Create bindings\n  var bindingsCreated = queueCreated.then(function() {\n    that._channel = channel;\n    return Promise.all(that._bindings.map(function(binding) {\n      debug('Binding %s to %s with pattern %s',\n        that._queueName || 'exclusive queue',\n        binding.exchange, binding.routingKeyPattern);\n      return channel.bindQueue(\n        that._queueName,\n        binding.exchange,\n        binding.routingKeyPattern\n      );\n    }));\n  });\n\n  // Begin consumption\n  return bindingsCreated.then(function() {\n    return channel;\n  });\n};\n\n/** Pause consumption of messages */\nPulseListener.prototype.pause = function() {\n  if (this._fake) {\n    assert(this._fakeListening, 'cannot pause when not listening');\n    this._fakeListening = false;\n    return Promise.resolve();\n  }\n\n  if (!this._channel) {\n    debug('WARNING: Paused PulseListener instance was wasn\\'t connected yet');\n    return Promise.resolve();\n  }\n  assert(this._channel, 'Can\\'t pause when not connected');\n  return this._channel.cancel(this._consumerTag);\n};\n\n/** Connect or resume consumption of message */\nPulseListener.prototype.resume = function() {\n  var that = this;\n\n  if (this._fake) {\n    assert(!this._fakeListening, 'cannot resume when already listening');\n    this._fakeListening = true;\n    return Promise.resolve();\n  }\n\n  return this.connect().then(function(channel) {\n    return channel.consume(that._queueName, function(msg) {\n      that._handle(msg);\n    }).then(function(result) {\n      that._consumerTag = result.consumerTag;\n    });\n  });\n};\n\n/** Inject a fake message\n *\n * Message has the form\n * {\n *   payload: data (not JSON encoded),\n *   exchange: exchange name\n *   routingKey: routing key (string)\n *   routes: [..] CC'd routes (without the `route.` prefix)\n * }\n */\nPulseListener.prototype.fakeMessage = function(message) {\n  assert(this._fake, 'fakeMessage can only be called on a fake PulseListener');\n  assert(this._fakeListening, 'fakeMessage must be called on a resume\\'d listener');\n  var msg = {\n    content: new Buffer(JSON.stringify(message.payload), 'utf-8'),\n    fields: {\n      exchange: message.exchange,\n      routingKey: message.routingKey,\n      redelivered: false,\n    },\n    properties: {\n      headers: {\n        CC: message.routes.map(function(r) { return 'route.' + r; }),\n      },\n    },\n  };\n  return this._handle(msg);\n};\n\n/** Handle message*/\nPulseListener.prototype._handle = function(msg) {\n  var that = this;\n  // Construct message\n  var message = {\n    payload:      JSON.parse(msg.content.toString('utf8')),\n    exchange:     msg.fields.exchange,\n    routingKey:   msg.fields.routingKey,\n    redelivered:  msg.fields.redelivered,\n    routes:       [],\n  };\n\n  // Find CC'ed routes\n  if (msg.properties && msg.properties.headers &&\n      msg.properties.headers.CC instanceof Array) {\n    message.routes = msg.properties.headers.CC.filter(function(route) {\n      // Only return the CC'ed routes that starts with \"route.\"\n      return /^route\\.(.*)$/.test(route);\n    }).map(function(route) {\n      // Remove the \"route.\"\n      return /^route\\.(.*)$/.exec(route)[1];\n    });\n  }\n\n  // Find routing key reference, if any is available to us\n  var routingKeyReference = null;\n  this._bindings.forEach(function(binding) {\n    if (binding.exchange === message.exchange && binding.routingKeyReference) {\n      routingKeyReference = binding.routingKeyReference;\n    }\n  });\n\n  // If we have a routing key reference we can parse the routing key\n  if (routingKeyReference) {\n    try {\n      var routing = {};\n      var keys = message.routingKey.split('.');\n      // first handle non-multi keys from the beginning\n      for (var i = 0; i < routingKeyReference.length; i++) {\n        var ref = routingKeyReference[i];\n        if (ref.multipleWords) {\n          break;\n        }\n        routing[ref.name] = keys.shift();\n      }\n      // If we reached a multi key\n      if (i < routingKeyReference.length) {\n        // then handle non-multi keys from the end\n        for (var j = routingKeyReference.length - 1; j > i; j--) {\n          var ref = routingKeyReference[j];\n          if (ref.multipleWords) {\n            break;\n          }\n          routing[ref.name] = keys.pop();\n        }\n        // Check that we only have one multiWord routing key\n        assert(i == j, 'i != j really shouldn\\'t be the case');\n        routing[routingKeyReference[i].name] = keys.join('.');\n      }\n\n      // Provide parsed routing key\n      message.routing = routing;\n    } catch (err) {\n      // Ideally we should rethrow the exception. But since it's not quite\n      // possible to promise that `routing` (the parsed routing key) is\n      // available... As you can subscribe without providing a routing\n      // key reference.\n      // In short people can assume this is present in most cases, and if they\n      // assume this we get the error at a level where they can handle it.\n      debug('Failed to parse routingKey: %s for %s with err: %s, as JSON: %j',\n        message.routingKey, message.exchange, err, err, err.stack);\n    }\n  }\n\n  // Process handlers\n  Promise.all(this.listeners('message').map(function(handler) {\n    return Promise.resolve(null).then(function() {\n      return handler.call(that, message);\n    });\n  })).then(function() {\n    if (!that._fake) {\n      return that._channel.ack(msg);\n    } else {\n      debug('Processed fake message %j from %s', message, message.exchange);\n    }\n  }).then(null, function(err) {\n    debug('Failed to process message %j from %s with error: %s, as JSON: %j',\n      message, message.exchange, err, err, err.stack);\n    if (that._fake) {\n      return;\n    }\n    if (message.redelivered) {\n      debug('Nack (without requeueing) message %j from %s',\n        message, message.exchange);\n      return that._channel.nack(msg, false, false);\n    } else {\n      // Nack and requeue\n      return that._channel.nack(msg, false, true);\n    }\n  }).then(null, function(err) {\n    debug('CRITICAL: Failed to nack message');\n    that.emit('error', err);\n  });\n};\n\n/**\n * Deletes the underlying queue and closes the listener\n *\n * Use this if you want to delete a named queue, unnamed queues created with\n * this listener will be automatically deleted, when the listener is closed.\n */\nPulseListener.prototype.deleteQueue = function() {\n  var that = this;\n  if (this._fake) {\n    return Promise.resolve();\n  }\n\n  return this.connect().then(function(channel) {\n    return channel.deleteQueue(that._queueName).then(function() {\n      that.close();\n    });\n  });\n};\n\n/** Close the PulseListener */\nPulseListener.prototype.close = function() {\n  var connection = this._connection;\n  if (this._fake) {\n    return Promise.resolve();\n  }\n\n  // If we were given connection by option, we shouldn't close it\n  if (connection === this._options.connection) {\n    var channel = this._channel;\n    if (channel) {\n      this._channel = null;\n      return channel.close();\n    }\n    return Promise.resolve(undefined);\n  }\n\n  // If not external connection close it\n  this._conn = null;\n  this._channel = null;\n  return connection.close();\n};\n\n// Export PulseListener\nexports.PulseListener = PulseListener;\n"
  ]
}
